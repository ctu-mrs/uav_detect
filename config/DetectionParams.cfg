#!/usr/bin/env python

## Pointcloud detection parameters
# Parameters are listed in the order in which the corresponding
# operations are executed (except for deprecated parameters).

PACKAGE='uav_detect'
import roslib;
roslib.load_manifest(PACKAGE)

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator();

params = gen.add_group("Pointcloud detection parameters");

# Image preprocessing parameters
params_preproc = params.add_group("Image preprocessing");
params_preproc.add("structuring_element_a", int_t, 1, "size of the structuring element major axis", 3, 1, 10);
params_preproc.add("structuring_element_b", int_t, 1, "size of the structuring element minor axis", 5, 1, 10);
params_preproc.add("dilate_iterations", int_t, 1, "how many times to dilate the image", 0, 0, 10);
params_preproc.add("erode_iterations", int_t, 1, "how many times to erode the image", 0, 0, 10);
params_preproc.add("erode_ignore_empty_iterations", int_t, 1, "how many times to erode the image (without using zeros for the erosion)", 0, 0, 10);
params_preproc.add("gaussianblur_size", int_t, 1, "size of gaussian blur kernel (must be odd number)", 0, 0, 50);
params_preproc.add("medianblur_size", int_t, 1, "size of gaussian blur kernel", 0, 0, 5);

# Pointcloud filtering parameters
params_filter = params.add_group("Pointcloud filtering");
params_filter.add("filtering_leaf_size", double_t, 1, "points, closer than this distance are filtered out (using voxel grid, meters)", 0.5, 0.0, 100.0);
params_filter.add("active_box_size", double_t, 1, "size of the box, used for filtering out distant points (meters)", 50.0, 0.0, 500.0);

# Pointcloud processing parameters
params_pcproc = params.add_group("Pointcloud processing");
params_pcproc.add("normal_debug", bool_t, 1, "whether to debug normals computation", False);
params_pcproc.add("normal_debug_row", int_t, 1, "which row to use for debugging", 0, 0, 63);
params_pcproc.add("normal_debug_col", int_t, 1, "which col to use for debugging", 0, 0, 2000);

normal_fit_enum = gen.enum([ gen.const("RANSAC", int_t, 0, "Random sample consensus for outlier-robust plane fitting"),
                             gen.const("SVD", int_t, 1, "Singular value decomposition for least squares plane fitting")],
                             "Plane fitting method for normal estimation")
params_pcproc.add("normal_method", int_t, 0, "Choose which plane fitting method to use", 0, 0, 1, edit_method=normal_fit_enum)

params_pcproc.add("normal_neighborhood_rows", int_t, 1, "how large is the used neighborhood in the row direction during the normal estimation step", 1, 0, 100);
params_pcproc.add("normal_neighborhood_cols", int_t, 1, "how large is the used neighborhood in the column direction during the normal estimation step", 6, 0, 100);

# params_pcproc.add("normal_threshold", double_t, 1, "threshold value of the RANSAC plane fitting during the normal estimation step", 1.0, 0.0, 100.0);
# params_pcproc.add("normal_iterations", int_t, 1, "maximal number of RANSAC iterations", 1000, 0, 10000);
# params_pcproc.add("normal_probability", double_t, 1, "probability of choosing at least one sample free from outliers during RANSAC", 0.99, 0.0, 1.0);

params_pcproc.add("meshing_MaximumNearestNeighbors", int_t, 1, "how many neighbors are searched for", 100, 0, 1000);
params_pcproc.add("meshing_Mu", double_t, 1, "maximal distance for neighbors to be considered", 3.0, 0.0, 100.0);
params_pcproc.add("meshing_SearchRadius", double_t, 1, "maximal edge length of each triangle", 3.0, 0.0, 100.0);
params_pcproc.add("meshing_MaximumSurfaceAngle", double_t, 1, "maximal angle between point normal and the triangle normal", 180.0, 0.0, 180.0);

params_pcproc.add("orgmesh_use_shadowed", bool_t, 1, "whether shadowed faces should be used or thrown away", True);
params_pcproc.add("orgmesh_shadow_ang_tol", int_t, 1, "angle tolerance when calculating shadowed faces (degrees)", 5, 0, 90);
params_pcproc.add("mesh_resample_points", int_t, 1, "to how many points should the mesh be resampled", 1000, 0, 100000);
params_pcproc.add("global_mesh_resample_points", int_t, 1, "to how many points should the global mesh be resampled", 5000, 0, 100000);
params_pcproc.add("intersection_tolerance", double_t, 1, "tolerance when evaluating ray and triangle intersection when filtering the global mesh", 0.5, 0.0, 5.0);

params_pcproc.add("point_decay_time", int_t, 1, "after this time (in seconds), a point will be discarded from the global pointcloud", 5, 0, 600);

exit(gen.generate(PACKAGE, "uav_detect", "DetectionParams"))
